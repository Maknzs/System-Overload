[{"filePath":"/home/maknzs/SystemOverload/frontend/src/App.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/Button.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/Card.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/DeckCard.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/DiscardPile.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/Modal.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/PrivacyScreen.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/components/TextInput.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/game/cards.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/main.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/pages/Game.jsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","message":"Definition for rule 'react-hooks/exhaustive-deps' was not found.","line":452,"column":5,"endLine":452,"endColumn":60,"severity":2,"nodeType":null},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":487,"column":17,"nodeType":"BlockStatement","messageId":"unexpected","endLine":487,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[13724,13724],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useReducer, useState } from \"react\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\nimport {\n  createDeck,\n  shuffle,\n  CARD,\n  CARD_IMG,\n  STOCK_CARD_IMG,\n  COMBO_CARDS,\n  CARD_DESC,\n} from \"../game/cards\";\nimport PrivacyScreen from \"../components/PrivacyScreen\";\nimport Card from \"../components/Card\";\nimport DeckCard from \"../components/DeckCard\";\nimport DiscardPile from \"../components/DiscardPile\";\nimport Button from \"../components/Button\";\nimport Modal from \"../components/Modal\";\nimport { api } from \"../api\";\nimport \"./Game.css\"; // page styles (section boxes, layout, log, etc.)\n\nconst PHASE = {\n  AWAIT_ACTION: \"AWAIT_ACTION\",\n  RESOLVE_FATAL: \"RESOLVE_FATAL\",\n  CHOOSING_FAVOR: \"CHOOSING_FAVOR\",\n  CHOOSING_PAIR_TARGET: \"CHOOSING_PAIR_TARGET\",\n  CHOOSING_PAIR_CARD: \"CHOOSING_PAIR_CARD\",\n  CHOOSING_TRIPLE_TARGET: \"CHOOSING_TRIPLE_TARGET\",\n  CHOOSING_TRIPLE_CARD: \"CHOOSING_TRIPLE_CARD\",\n};\n\nconst REQUESTABLE_CARDS = [\n  CARD.REBOOT,\n  CARD.SKIP,\n  CARD.ATTACK,\n  CARD.SHUFFLE,\n  CARD.FUTURE,\n  CARD.FAVOR,\n  CARD.TAMPERED,\n  CARD.NEW_ERROR,\n  CARD.VALID_CREDS,\n  CARD.ROGUE_AV,\n  CARD.COFFEE,\n];\n\nconst HAND_DISPLAY_ORDER = [\n  CARD.REBOOT,\n  CARD.SKIP,\n  CARD.ATTACK,\n  CARD.SHUFFLE,\n  CARD.FUTURE,\n  CARD.FAVOR,\n  \"Tampered Data Log\",\n  \"New Error Code\",\n  \"Valid Credentials?\",\n  \"Rogue Anti-virus Software\",\n  \"Coffee Fueled Programmer\",\n];\n\nconst STACK_SPACING = 20; // px gap between stacked duplicate cards\n\nfunction initialState(names) {\n  const { deck, hands } = createDeck(names.length);\n  return {\n    players: names.map((n, i) => ({ id: i, name: n, alive: true })),\n    turn: 0,\n    turnsToTake: 1, // active player's remaining turns (DDoS stack)\n    deck,\n    discard: [],\n    hands,\n    peek: [], // Health Check preview (top 3)\n    log: [],\n    phase: PHASE.AWAIT_ACTION,\n    combo: null,\n    drawnCard: null,\n    advanceAfterDraw: false,\n\n    // Attack handoff\n    pendingExtraTurnsFor: null, // who will receive extra turns next\n    extraTurns: 0,\n\n    // combo/fatal/winner handling\n    comboTarget: null,\n    fatalCard: null,\n    winner: null,\n  };\n}\n\nfunction nextAlive(state, from) {\n  let i = from;\n  for (let step = 0; step < state.players.length; step++) {\n    i = (i + 1) % state.players.length;\n    if (state.players[i].alive) return i;\n  }\n  return from;\n}\n\n// Advance the turn, respecting remaining-turns and queued Attack turns\nfunction advanceTurn(S) {\n  const pid = S.turn;\n\n  // If current player still owes more turns (from DDoS), stay on them.\n  if (S.turnsToTake > 1) {\n    S.turnsToTake -= 1;\n    S.log.push(\n      `${S.players[pid].name} continues (remaining turns: ${S.turnsToTake}).`\n    );\n    S.peek = [];\n    return S;\n  }\n\n  // If an Attack queued extra turns for the next player, hand it off now.\n  if (S.pendingExtraTurnsFor != null && S.extraTurns > 0) {\n    const nxt = nextAlive(S, pid);\n    S.turn = nxt;\n    S.turnsToTake = S.extraTurns;\n    S.extraTurns = 0; // ← use 0, not null\n    S.pendingExtraTurnsFor = null; // ← clear the flag after handoff\n    S.log.push(\n      `${S.players[nxt].name} begins ${S.turnsToTake} forced turn(s).`\n    );\n    S.peek = [];\n    return S;\n  }\n\n  // Normal next player\n  S.turn = nextAlive(S, pid);\n  S.turnsToTake = 1;\n  S.peek = [];\n  return S;\n}\n\nfunction ordinal(n) {\n  const s = [\"th\", \"st\", \"nd\", \"rd\"],\n    v = n % 100;\n  return n + (s[(v - 20) % 10] || s[v] || s[0]);\n}\n\nfunction reducer(state, action) {\n  const S = {\n    ...state,\n    players: state.players.slice(),\n    hands: state.hands.map((h) => h.slice()),\n    deck: state.deck.slice(),\n    discard: state.discard.slice(),\n    log: state.log.slice(),\n    peek: state.peek.slice(),\n  };\n\n  switch (action.type) {\n    case \"INIT\":\n      return initialState(action.names);\n\n    case \"CLEAR_PEEK\":\n      S.peek = [];\n      return S;\n\n    case \"DRAW\": {\n      if (!S.deck.length) {\n        S.log.push(\"Deck empty. Shuffling discard into deck.\");\n        S.deck = shuffle(S.discard);\n        S.discard = [];\n      }\n      const pid = S.turn;\n      const card = S.deck.pop();\n\n      if (card === CARD.FATAL) {\n        S.log.push(`${S.players[pid].name} drew a ${CARD.FATAL}!`);\n        S.phase = PHASE.RESOLVE_FATAL;\n        S.fatalCard = CARD.FATAL;\n        return S;\n      }\n\n      // Safe draw -> add to hand, show modal, advance after close\n      S.hands[pid].push(card);\n      S.log.push(`${S.players[pid].name} drew a card.`);\n      S.drawnCard = card;\n      S.advanceAfterDraw = true;\n      return S;\n    }\n\n    case \"END_DRAW\": {\n      S.drawnCard = null;\n      const shouldAdvance = S.advanceAfterDraw;\n      S.advanceAfterDraw = false;\n      return shouldAdvance ? advanceTurn(S) : S;\n    }\n\n    case \"PLAY_SKIP\": {\n      const pid = S.turn;\n      const i = S.hands[pid].indexOf(CARD.SKIP);\n      if (i === -1) return S;\n      S.hands[pid].splice(i, 1);\n      S.discard.push(CARD.SKIP);\n      S.log.push(\n        `${S.players[pid].name} played ${CARD.SKIP} (skip remaining turns).`\n      );\n      return advanceTurn(S);\n    }\n\n    case \"PLAY_ATTACK\": {\n      const pid = S.turn;\n      const i = S.hands[pid].indexOf(CARD.ATTACK);\n      if (i === -1) return S;\n      S.hands[pid].splice(i, 1);\n      S.discard.push(CARD.ATTACK);\n\n      const nxt = nextAlive(S, pid);\n      S.pendingExtraTurnsFor = nxt;\n      S.extraTurns = 2; // +2 turns for next player\n      S.log.push(\n        `${S.players[pid].name} launched ${CARD.ATTACK}. ${S.players[nxt].name} must take +2 turns.`\n      );\n      return advanceTurn(S);\n    }\n\n    case \"PLAY_SHUFFLE\": {\n      const pid = S.turn;\n      const i = S.hands[pid].indexOf(CARD.SHUFFLE);\n      if (i === -1) return S;\n      S.hands[pid].splice(i, 1);\n      S.discard.push(CARD.SHUFFLE);\n      S.deck = shuffle(S.deck);\n      S.log.push(`${S.players[pid].name} played ${CARD.SHUFFLE}.`);\n      return S;\n    }\n\n    case \"PLAY_FUTURE\": {\n      const pid = S.turn;\n      const i = S.hands[pid].indexOf(CARD.FUTURE);\n      if (i === -1) return S;\n      S.hands[pid].splice(i, 1);\n      S.discard.push(CARD.FUTURE);\n      S.peek = S.deck.slice(-3); // end = top\n      S.log.push(`${S.players[pid].name} ran ${CARD.FUTURE}.`);\n      return S;\n    }\n\n    case \"PLAY_FAVOR\": {\n      const pid = S.turn;\n      const i = S.hands[pid].indexOf(CARD.FAVOR);\n      if (i === -1) return S;\n      S.hands[pid].splice(i, 1);\n      S.discard.push(CARD.FAVOR);\n      S.phase = PHASE.CHOOSING_FAVOR;\n      S.log.push(\n        `${S.players[pid].name} used ${CARD.FAVOR}. Choose a player to request one random card.`\n      );\n      return S;\n    }\n\n    case \"RESOLVE_FAVOR_FROM\": {\n      const toId = action.toId; // target who gives\n      const fromId = S.turn; // current player receives\n      const opp = S.hands[toId];\n\n      if (opp.length === 0) {\n        S.log.push(`${S.players[toId].name} has no cards to give.`);\n      } else {\n        const idx = Math.floor(Math.random() * opp.length);\n        const given = opp.splice(idx, 1)[0];\n        S.hands[fromId].push(given);\n        S.drawnCard = given;\n        S.advanceAfterDraw = false;\n\n        // visible to everyone EXCEPT the two involved\n        S.log.push({\n          text: `${S.players[fromId].name} received a random card from ${S.players[toId].name}.`,\n          exclude: [fromId, toId],\n        });\n        // precise card only to the two involved\n        S.log.push({\n          text: `${S.players[fromId].name} received the card: ${given} from ${S.players[toId].name}.`,\n          visibleTo: [fromId, toId],\n        });\n      }\n\n      S.phase = PHASE.AWAIT_ACTION;\n      return S;\n    }\n\n    case \"START_COMBO\": {\n      const pid = S.turn;\n      const { cardName, mode } = action;\n      const removeCount = mode === \"TRIPLE\" ? 3 : 2;\n      for (let k = 0; k < removeCount; k++) {\n        const idx = S.hands[pid].indexOf(cardName);\n        if (idx !== -1) S.hands[pid].splice(idx, 1);\n        S.discard.push(cardName);\n      }\n      S.combo = { type: mode, card: cardName };\n      S.comboTarget = null;\n      S.phase =\n        mode === \"TRIPLE\"\n          ? PHASE.CHOOSING_TRIPLE_TARGET\n          : PHASE.CHOOSING_PAIR_TARGET;\n      S.log.push(\n        `${S.players[pid].name} played a ${mode.toLowerCase()} of ${cardName}.`\n      );\n      return S;\n    }\n\n    case \"RESOLVE_PAIR_TARGET\": {\n      const toId = action.toId;\n      S.comboTarget = toId;\n      S.hands[toId] = shuffle(S.hands[toId]);\n      S.phase = PHASE.CHOOSING_PAIR_CARD;\n      return S;\n    }\n\n    case \"RESOLVE_PAIR_FROM\": {\n      const pid = S.turn;\n      const toId = S.comboTarget;\n      const opp = S.hands[toId];\n\n      if (opp.length === 0) {\n        S.log.push(`${S.players[toId].name} had no cards to steal.`);\n      } else {\n        const idx = Math.min(action.index, opp.length - 1);\n        const given = opp.splice(idx, 1)[0];\n        S.hands[pid].push(given);\n        S.log.push(\n          `${S.players[pid].name} stole a card from ${S.players[toId].name}.`\n        );\n        S.drawnCard = given;\n        S.advanceAfterDraw = false;\n      }\n\n      S.comboTarget = null;\n      S.combo = null;\n      S.phase = PHASE.AWAIT_ACTION;\n      return S;\n    }\n\n    case \"RESOLVE_TRIPLE_TARGET\": {\n      S.comboTarget = action.toId;\n      S.phase = PHASE.CHOOSING_TRIPLE_CARD;\n      return S;\n    }\n\n    case \"RESOLVE_TRIPLE_NAME\": {\n      const pid = S.turn;\n      const toId = S.comboTarget;\n      const cardName = action.cardName;\n      const opp = S.hands[toId];\n      const idx = opp.indexOf(cardName);\n      if (idx !== -1) {\n        opp.splice(idx, 1);\n        S.hands[pid].push(cardName);\n        S.drawnCard = cardName;\n        S.advanceAfterDraw = false;\n        S.log.push(\n          `${S.players[pid].name} received ${cardName} from ${S.players[toId].name}.`\n        );\n      } else {\n        S.log.push(`${S.players[toId].name} did not have ${cardName}.`);\n      }\n      S.comboTarget = null;\n      S.combo = null;\n      S.phase = PHASE.AWAIT_ACTION;\n      return S;\n    }\n\n    case \"USE_REBOOT_OR_EXPLODE\": {\n      const pid = S.turn;\n      const idx = S.hands[pid].indexOf(CARD.REBOOT);\n      if (idx !== -1) {\n        // Player has Reboot; remove it now. The UI will follow with REBOOT_INSERT.\n        S.hands[pid].splice(idx, 1);\n        // Do NOT discard here yet; we’ll count it as used when we reinsert the Fatal.\n        S.phase = PHASE.AWAIT_ACTION;\n        return S;\n      } else {\n        // No Reboot: player eliminated\n        S.players[pid].alive = false;\n        S.turnsToTake = 0;\n        S.discard.push(CARD.FATAL);\n        S.fatalCard = null;\n        S.phase = PHASE.AWAIT_ACTION;\n        S.peek = [];\n        S.log.push(`${S.players[pid].name} exploded and is out!`);\n\n        const alive = S.players.filter((p) => p.alive).length;\n        if (alive === 1) {\n          S.winner = S.players.find((p) => p.alive).name;\n          return S;\n        }\n        return advanceTurn(S);\n      }\n    }\n\n    case \"REBOOT_INSERT\": {\n      // Player chose where to put the Fatal back. Top = 0 (end of array).\n      const pos = action.pos;\n      const insertIndex = Math.max(0, S.deck.length - pos); // guard negatives\n      S.deck.splice(insertIndex, 0, CARD.FATAL);\n      // Count the reboot as used now (single discard record)\n      S.discard.push(CARD.REBOOT);\n      S.fatalCard = null;\n      S.phase = PHASE.AWAIT_ACTION;\n      S.log.push(\n        `${S.players[S.turn].name} used ${CARD.REBOOT} and reinserted the ${\n          CARD.FATAL\n        }.`\n      );\n      return advanceTurn(S);\n    }\n\n    default:\n      return state;\n  }\n}\n\nexport default function Game() {\n  const nav = useNavigate();\n  const { state } = useLocation();\n  const names = (state?.names || [\"Player 1\", \"Player 2\"])\n    .map((s) => s.trim())\n    .filter(Boolean);\n\n  const [game, dispatch] = useReducer(reducer, initialState(names));\n  const [hideHand, setHideHand] = useState(true);\n  const [selectedCard, setSelectedCard] = useState(null);\n  const [showPeekModal, setShowPeekModal] = useState(false);\n  const [flipFatal, setFlipFatal] = useState(false);\n\n  const me = game.players[game.turn];\n  const hand = game.hands[game.turn];\n  const hasReboot = hand.includes(CARD.REBOOT);\n  const sortedHand = [...hand].sort((a, b) => {\n    const ai = HAND_DISPLAY_ORDER.indexOf(a);\n    const bi = HAND_DISPLAY_ORDER.indexOf(b);\n    const aIndex = ai === -1 ? Number.MAX_VALUE : ai;\n    const bIndex = bi === -1 ? Number.MAX_VALUE : bi;\n    if (aIndex === bIndex) return 0;\n    return aIndex - bIndex;\n  });\n\n  const groupedHand = [];\n  for (const card of sortedHand) {\n    const last = groupedHand[groupedHand.length - 1];\n    if (last && last.card === card) {\n      last.count += 1;\n    } else {\n      groupedHand.push({ card, count: 1 });\n    }\n  }\n\n  // Init once\n  useEffect(() => {\n    dispatch({ type: \"INIT\", names });\n    setHideHand(true);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Show pass-device modal whenever turn changes\n  useEffect(() => {\n    setHideHand(true);\n  }, [game.turn]);\n\n  // Show Health Check modal with top 3 cards\n  useEffect(() => {\n    if (game.peek.length > 0) {\n      setShowPeekModal(true);\n      const timer = setTimeout(() => {\n        setShowPeekModal(false);\n        dispatch({ type: \"CLEAR_PEEK\" });\n      }, 5000);\n      return () => clearTimeout(timer);\n    }\n    setShowPeekModal(false);\n  }, [game.peek]);\n\n  // Auto-close draw modal after 5 seconds\n  useEffect(() => {\n    if (game.drawnCard) {\n      const timer = setTimeout(() => dispatch({ type: \"END_DRAW\" }), 5000);\n      return () => clearTimeout(timer);\n    }\n  }, [game.drawnCard]);\n\n  // Winner flow\n  useEffect(() => {\n    if (game.winner) {\n      (async () => {\n        try {\n          await api.incrementGamesPlayed();\n        } catch {}\n        alert(`Winner: ${game.winner}`);\n        nav(\"/\");\n      })();\n    }\n  }, [game.winner, nav]);\n\n  // Flip fatal card when no Reboot available\n  useEffect(() => {\n    if (game.phase === PHASE.RESOLVE_FATAL && !hasReboot) {\n      const interval = setInterval(() => setFlipFatal((f) => !f), 750);\n      return () => clearInterval(interval);\n    }\n    setFlipFatal(false);\n  }, [game.phase, hasReboot]);\n\n  const fatalCardSrc =\n    game.phase === PHASE.RESOLVE_FATAL && !hasReboot && flipFatal\n      ? STOCK_CARD_IMG\n      : CARD_IMG[CARD.FATAL];\n\n  const countAlive = game.players.filter((p) => p.alive).length;\n  const canPlayNow =\n    game.phase === PHASE.AWAIT_ACTION && !hideHand && !game.drawnCard;\n\n  const selectedCount = selectedCard\n    ? hand.filter((h) => h === selectedCard).length\n    : 0;\n  const isActionCard = [\n    CARD.SKIP,\n    CARD.ATTACK,\n    CARD.SHUFFLE,\n    CARD.FUTURE,\n    CARD.FAVOR,\n    CARD.REBOOT,\n  ].includes(selectedCard);\n  const canPlaySelected =\n    isActionCard &&\n    (selectedCard !== CARD.REBOOT\n      ? canPlayNow\n      : game.phase === PHASE.RESOLVE_FATAL);\n  const canPair =\n    COMBO_CARDS.includes(selectedCard) && selectedCount >= 2 && canPlayNow;\n  const canTriple =\n    COMBO_CARDS.includes(selectedCard) && selectedCount >= 3 && canPlayNow;\n\n  function playCardByName(cardName) {\n    if (!me?.alive) return;\n\n    // If we’re resolving a Fatal, only Reboot makes sense here\n    if (game.phase === PHASE.RESOLVE_FATAL) {\n      if (cardName === CARD.REBOOT) {\n        // Show your “choose position” UI or just reinsert top as example\n        dispatch({ type: \"USE_REBOOT_OR_EXPLODE\" });\n        dispatch({ type: \"REBOOT_INSERT\", pos: 0 });\n      }\n      return;\n    }\n\n    if (!canPlayNow) return;\n\n    switch (cardName) {\n      case CARD.SKIP:\n        dispatch({ type: \"PLAY_SKIP\" });\n        break;\n      case CARD.ATTACK:\n        dispatch({ type: \"PLAY_ATTACK\" });\n        break;\n      case CARD.SHUFFLE:\n        dispatch({ type: \"PLAY_SHUFFLE\" });\n        break;\n      case CARD.FUTURE:\n        dispatch({ type: \"PLAY_FUTURE\" });\n        break;\n      case CARD.FAVOR:\n        dispatch({ type: \"PLAY_FAVOR\" });\n        break;\n      // REBOOT is not playable during normal flow (only after a Fatal draw)\n      default:\n        // Non-action cards are handled elsewhere\n        break;\n    }\n  }\n\n  function onResolveFatal() {\n    dispatch({ type: \"USE_REBOOT_OR_EXPLODE\" });\n  }\n  function onReinsert(posFromTop) {\n    dispatch({ type: \"REBOOT_INSERT\", pos: posFromTop });\n  }\n\n  return (\n    <div className=\"page\">\n      <h1 className=\"page-header\">System Overload</h1>\n\n      {/* Meta pills */}\n      <div className=\"meta\">\n        <span className=\"pill\">\n          Players alive: {countAlive} / {game.players.length}\n        </span>\n        <span className=\"pill\">\n          Turn:\n          <b style={{ marginLeft: 6 }}>{me?.name}</b>\n          <span className=\"subtle\" style={{ marginLeft: 6 }}>\n            (Take {game.turnsToTake} turn{game.turnsToTake > 1 ? \"s\" : \"\"})\n          </span>\n        </span>\n      </div>\n\n      {/* Pass-Device modal */}\n      <PrivacyScreen\n        show={hideHand}\n        playerName={me?.name}\n        onContinue={() => setHideHand(false)}\n      />\n\n      {/* Deck / Discard */}\n      <div className=\"deck-area\">\n        <div className=\"card deck-area__right\">\n          <DiscardPile cards={game.discard} maxToShow={10} />\n        </div>\n        <div className=\"card deck-area__left\">\n          <DeckCard\n            count={game.deck.length}\n            onClick={() => dispatch({ type: \"DRAW\" })}\n            disabled={\n              hideHand || game.phase !== PHASE.AWAIT_ACTION || !!game.drawnCard\n            }\n          />\n          <div>\n            <div style={{ fontSize: 60, fontWeight: 900, color: \"red\" }}>\n              {game.deck.length}\n            </div>\n            <div className=\"section-title\" style={{ color: \"red\" }}>\n              Cards\n              <br />\n              Remain\n              <br />\n              ← Click\n              <br />\n              for your <br />\n              FATE\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Drawn card modal */}\n      <Modal show={!!game.drawnCard}>\n        {game.drawnCard && (\n          <>\n            <div className=\"modal-title\">{game.drawnCard}</div>\n            <div\n              className=\"hstack\"\n              style={{ justifyContent: \"center\", margin: \"10px 0\" }}\n            >\n              <Card\n                name={game.drawnCard}\n                size=\"deck\"\n                disabled\n                style={{\n                  width: \"calc(var(--card-deck-w) * 2)\",\n                  height: \"calc(var(--card-deck-h) * 2)\",\n                }}\n              />\n            </div>\n            <div className=\"subtle\" style={{ marginBottom: 12 }}>\n              {CARD_DESC[game.drawnCard]}\n            </div>\n            <Button onClick={() => dispatch({ type: \"END_DRAW\" })}>\n              Close\n            </Button>\n          </>\n        )}\n      </Modal>\n\n      {/* Health Check modal */}\n      <Modal show={showPeekModal}>\n        <div className=\"section-title\">Health Check (top 3)</div>\n        <div className=\"hstack\" style={{ justifyContent: \"center\" }}>\n          {[...game.peek].reverse().map((c, i) => (\n            <div key={i} className=\"peek-card\">\n              <Card name={c} />\n              <div className=\"peek-order\">{i + 1}</div>\n            </div>\n          ))}\n        </div>\n        <div style={{ marginTop: 12 }}>\n          <Button\n            onClick={() => {\n              setShowPeekModal(false);\n              dispatch({ type: \"CLEAR_PEEK\" });\n            }}\n          >\n            Close\n          </Button>\n        </div>\n      </Modal>\n\n      {/* Fatal resolution */}\n      <Modal show={game.phase === PHASE.RESOLVE_FATAL}>\n        <div className=\"modal-title\">{CARD.FATAL}!</div>\n        <div\n          className=\"hstack\"\n          style={{ justifyContent: \"center\", margin: \"10px 0\" }}\n        >\n          <Card\n            name={CARD.FATAL}\n            size=\"deck\"\n            disabled\n            src={fatalCardSrc}\n            style={{\n              width: \"calc(var(--card-deck-w) * 2)\",\n              height: \"calc(var(--card-deck-h) * 2)\",\n            }}\n          />\n        </div>\n        {hasReboot ? (\n          <>\n            <div className=\"subtle\" style={{ marginBottom: 10 }}>\n              Use {CARD.REBOOT} and choose where to put the Fatal back:\n            </div>\n            <div className=\"hstack\" style={{ justifyContent: \"center\" }}>\n              {Array.from({ length: game.deck.length + 1 }).map((_, pos) => (\n                <Button\n                  key={pos}\n                  onClick={() => {\n                    dispatch({ type: \"USE_REBOOT_OR_EXPLODE\" });\n                    onReinsert(pos);\n                  }}\n                >\n                  {pos === 0\n                    ? \"Top\"\n                    : pos === game.deck.length\n                    ? \"Bottom\"\n                    : ordinal(pos + 1)}\n                </Button>\n              ))}\n            </div>\n          </>\n        ) : (\n          <>\n            <div className=\"modal-title\" style={{ fontSize: 40 }}>\n              No {CARD.REBOOT} available! System Overload!\n            </div>\n            <Button onClick={onResolveFatal}>Continue</Button>\n          </>\n        )}\n      </Modal>\n\n      {/* Favor target selection */}\n      <Modal show={game.phase === PHASE.CHOOSING_FAVOR}>\n        <div className=\"section-title\">\n          Choose a player to take a random card from\n        </div>\n        <div className=\"hstack\">\n          {game.players\n            .filter((p) => p.alive && p.id !== game.turn)\n            .map((p) => (\n              <Button\n                key={p.id}\n                onClick={() =>\n                  dispatch({ type: \"RESOLVE_FAVOR_FROM\", toId: p.id })\n                }\n              >\n                {p.name}\n              </Button>\n            ))}\n        </div>\n      </Modal>\n\n      {/* Pair target selection */}\n      <Modal show={game.phase === PHASE.CHOOSING_PAIR_TARGET}>\n        <div className=\"section-title\">\n          Choose a player to steal a card from\n        </div>\n        <div className=\"hstack\">\n          {game.players\n            .filter((p) => p.alive && p.id !== game.turn)\n            .map((p) => (\n              <Button\n                key={p.id}\n                onClick={() =>\n                  dispatch({ type: \"RESOLVE_PAIR_TARGET\", toId: p.id })\n                }\n              >\n                {p.name}\n              </Button>\n            ))}\n        </div>\n      </Modal>\n\n      {/* Pair card selection */}\n      <Modal\n        show={\n          game.phase === PHASE.CHOOSING_PAIR_CARD && game.comboTarget != null\n        }\n      >\n        <div className=\"section-title\">\n          Choose a card from{\" \"}\n          {game.comboTarget != null\n            ? game.players[game.comboTarget].name\n            : \"selected player\"}\n        </div>\n        <div className=\"hstack\">\n          {(game.comboTarget != null ? game.hands[game.comboTarget] : []).map(\n            (_, i) => (\n              <Card\n                key={i}\n                name=\"Hidden\"\n                faceDown\n                allowClickWhenFaceDown\n                onClick={() =>\n                  dispatch({ type: \"RESOLVE_PAIR_FROM\", index: i })\n                }\n              />\n            )\n          )}\n        </div>\n      </Modal>\n\n      {/* Triple target selection */}\n      <Modal show={game.phase === PHASE.CHOOSING_TRIPLE_TARGET}>\n        <div className=\"section-title\">\n          Choose a player to request a specific card from\n        </div>\n        <div className=\"hstack\">\n          {game.players\n            .filter((p) => p.alive && p.id !== game.turn)\n            .map((p) => (\n              <Button\n                key={p.id}\n                onClick={() =>\n                  dispatch({ type: \"RESOLVE_TRIPLE_TARGET\", toId: p.id })\n                }\n              >\n                {p.name}\n              </Button>\n            ))}\n        </div>\n      </Modal>\n\n      {/* Triple card selection */}\n      <Modal\n        show={\n          game.phase === PHASE.CHOOSING_TRIPLE_CARD && game.comboTarget != null\n        }\n      >\n        <div className=\"section-title\">\n          Request a card from{\" \"}\n          {game.comboTarget != null\n            ? game.players[game.comboTarget].name\n            : \"selected player\"}\n        </div>\n        <div className=\"hstack\" style={{ flexWrap: \"wrap\" }}>\n          {REQUESTABLE_CARDS.map((n) => (\n            <Card\n              key={n}\n              name={n}\n              onClick={() =>\n                dispatch({ type: \"RESOLVE_TRIPLE_NAME\", cardName: n })\n              }\n            />\n          ))}\n        </div>\n      </Modal>\n\n      {/* Card action modal */}\n      <Modal show={selectedCard !== null}>\n        {selectedCard && (\n          <>\n            <div className=\"section-title\">{selectedCard}</div>\n            <div\n              className=\"hstack\"\n              style={{ justifyContent: \"center\", margin: \"10px 0\" }}\n            >\n              <Card\n                name={selectedCard}\n                size=\"deck\"\n                disabled\n                style={{\n                  width: \"calc(var(--card-deck-w) * 2)\",\n                  height: \"calc(var(--card-deck-h) * 2)\",\n                }}\n              />\n            </div>\n            <div className=\"subtle\" style={{ marginBottom: 12 }}>\n              {CARD_DESC[selectedCard]}\n            </div>\n            {COMBO_CARDS.includes(selectedCard) && selectedCount < 2 && (\n              <div className=\"subtle\" style={{ marginBottom: 12 }}>\n                This card must be paired to have available actions.\n              </div>\n            )}\n            {selectedCard === CARD.REBOOT && (\n              <div className=\"subtle\" style={{ marginBottom: 12 }}>\n                This card is only used to deactivate a Fatal Server Error when\n                drawn. It cannot be played during your turn.\n              </div>\n            )}\n            <div className=\"hstack\" style={{ justifyContent: \"center\" }}>\n              {isActionCard && (\n                <Button\n                  onClick={() => {\n                    playCardByName(selectedCard);\n                    setSelectedCard(null);\n                  }}\n                  disabled={!canPlaySelected}\n                >\n                  Play\n                </Button>\n              )}\n              {COMBO_CARDS.includes(selectedCard) && (\n                <>\n                  <Button\n                    onClick={() => {\n                      dispatch({\n                        type: \"START_COMBO\",\n                        cardName: selectedCard,\n                        mode: \"PAIR\",\n                      });\n                      setSelectedCard(null);\n                    }}\n                    disabled={!canPair}\n                  >\n                    Pair\n                  </Button>\n                  <Button\n                    onClick={() => {\n                      dispatch({\n                        type: \"START_COMBO\",\n                        cardName: selectedCard,\n                        mode: \"TRIPLE\",\n                      });\n                      setSelectedCard(null);\n                    }}\n                    disabled={!canTriple}\n                  >\n                    Triple\n                  </Button>\n                </>\n              )}\n              <Button onClick={() => setSelectedCard(null)}>Cancel</Button>\n            </div>\n          </>\n        )}\n      </Modal>\n\n      {/* Hand */}\n      <div className=\"card\" style={{ marginBottom: 16 }}>\n        <div className=\"section-title\">\n          {me?.name} — Hand ({hand.length})\n        </div>\n\n        <div\n          className=\"hstack\"\n          style={{ flexWrap: \"wrap\", columnGap: 0, rowGap: 8 }}\n        >\n          {groupedHand.map(({ card: c, count }, i) => {\n            const canInspect =\n              game.phase === PHASE.AWAIT_ACTION && !hideHand && !game.drawnCard;\n            const isPlayable =\n              canInspect &&\n              (c === CARD.SKIP ||\n                c === CARD.ATTACK ||\n                c === CARD.SHUFFLE ||\n                c === CARD.FUTURE ||\n                c === CARD.FAVOR ||\n                (COMBO_CARDS.includes(c) && count >= 2));\n            const needsPair =\n              canInspect && COMBO_CARDS.includes(c) && count < 2;\n            const showInfo = needsPair || (canInspect && c === CARD.REBOOT);\n\n            if (count === 1) {\n              return (\n                <Card\n                  key={i}\n                  name={c}\n                  size=\"hand\"\n                  faceDown={hideHand}\n                  onClick={() => setSelectedCard(c)}\n                  disabled={!isPlayable}\n                  onDisabledClick={\n                    showInfo ? () => setSelectedCard(c) : undefined\n                  }\n                />\n              );\n            }\n\n            return (\n              <div\n                className=\"hand-stack\"\n                key={i}\n                style={{\n                  \"--stack-count\": count,\n                  \"--stack-spacing\": `${STACK_SPACING}px`,\n                }}\n              >\n                {Array.from({ length: count }).map((_, j) => (\n                  <Card\n                    key={j}\n                    name={c}\n                    size=\"hand\"\n                    faceDown={hideHand}\n                    onClick={() => setSelectedCard(c)}\n                    disabled={!isPlayable}\n                    onDisabledClick={\n                      showInfo ? () => setSelectedCard(c) : undefined\n                    }\n                    style={{ \"--stack-index\": j }}\n                  />\n                ))}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n\n      {/* Log with per-viewer visibility */}\n      <div className=\"card\">\n        <div className=\"section-title\">Game Log</div>\n        {(() => {\n          const viewerId = me?.id;\n          const visible = game.log.filter((entry) => {\n            if (typeof entry === \"string\") return true;\n            if (entry.visibleTo) return entry.visibleTo.includes(viewerId);\n            if (entry.exclude) return !entry.exclude.includes(viewerId);\n            return true;\n          });\n          return (\n            <ul className=\"list scroll\">\n              {visible.map((entry, i) => (\n                <li key={i}>\n                  {typeof entry === \"string\" ? (\n                    entry\n                  ) : (\n                    <span\n                      dangerouslySetInnerHTML={{\n                        __html: entry.text.replace(\n                          /\\*\\*(.*?)\\*\\*/g,\n                          \"<b>$1</b>\"\n                        ),\n                      }}\n                    />\n                  )}\n                </li>\n              ))}\n            </ul>\n          );\n        })()}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/pages/Lobby.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/pages/Login.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/pages/Menu.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/maknzs/SystemOverload/frontend/src/pages/Register.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
